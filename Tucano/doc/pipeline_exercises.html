<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tucano: GPU Pipeline Exercises</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="tucano.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tucano
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A library for rapid prototyping with modern OpenGL and GLSL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('pipeline_exercises.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">GPU Pipeline Exercises </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Once you have completed the <a class="el" href="transformation_exercises.html">Transformation Exercises</a> it is time to start working with the Shaders, the real meat of OpenGL. For the following exercises you will work on four different files:</p>
<ul>
<li>widget.cpp</li>
<li>simpleshader.hpp</li>
<li>shading.vert</li>
<li>shadeing.frag</li>
</ul>
<p>You will make small alterations along the whole pipeline, and hopefully, by the end of these exercises you will understand how the rendering pipeline works in practice.</p>
<p>If you run the <em>shaders-pipeline</em> program without any modifications, you should see the following green triangle on your screen:</p>
<blockquote class="doxtable">
<div class="image">
<img src="pipeline-initial.png" alt="pipeline-initial.png"/>
</div>
 </blockquote>
<blockquote class="doxtable">
<p><b>Tip</b>: if you press 'S' a screenshot of your application will be saved in a PPM file. </p>
</blockquote>
<p>For each of the exercises below you can find a screenshot of the solutions in the folder <b>solutions</b></p>
<p><br />
<br />
 </p><hr/>
<h2>Exercise 1 - change the triangle color</h2>
<p>The first exercise is very simple. Go to the <b>shading.frag</b> file and change the color to orange (Red=1.0, Green=0.5, Blue=0.0). Note that when you modify the fragment shader, all the generated fragments from the triangle will be effected.</p>
<blockquote class="doxtable">
<p><b>Tip</b>: you can reload the shaders at run time, no need to exit your application and recompile the code. Just make the modification on the shader file, save it, and press 'R'. If there are no errors, your shader will be recompiled and reloaded, and you will see the changes immediately. </p>
</blockquote>
<p>Now your triangle should look like this:</p>
<blockquote class="doxtable">
<div class="image">
<img src="pipeline-exercise1.png" alt="pipeline-exercise1.png"/>
</div>
 </blockquote>
<p><br />
<br />
 </p><hr/>
<h2>Exercise 2 - translate the triangle within the shader</h2>
<p>Now let's try to modify the vertex shader <b>shading.vert</b>. Note that when you modify your vertex shader, the changes will apply to all vertices, in this case the three vertices of the triangle.</p>
<p>Add the following translation vector to your vertices:</p><ul>
<li>0.5 in the x axis and -0.5 in the y axis</li>
<li>your translation vector should be of type <em>vec4</em> in GLSL.</li>
</ul>
<blockquote class="doxtable">
<p><b>Tip</b>: add a <em>vec4(x,y,z,w)</em> to the <em>vert</em> variable </p>
</blockquote>
<blockquote class="doxtable">
<p><b>Note</b>: what is the correct value of <em>w</em> for the translation vector? </p>
</blockquote>
<p>Your triangle should have moved to the bottom right corner of the screen (independent of the color):</p>
<blockquote class="doxtable">
<div class="image">
<img src="pipeline-exercise2.png" alt="pipeline-exercise2.png"/>
</div>
 </blockquote>
<p><br />
<br />
 </p><hr/>
<h2>Exercise 3 - rotate the triangle by passing a new matrix to the shader (uniform variables)</h2>
<blockquote class="doxtable">
<p><b>Note</b>: remove the translation from the previous exercise before starting, so your triangle is again centered. </p>
</blockquote>
<p>In GLSL there is no rotation method, as we have seen with the <a class="el" href="eigen.html">Eigen library</a>. One option is to create a rotation matrix inside the shader, just as you did with the translation in the last exercise. Another option is to rotate the Model or View matrices, as we have seen in the <a class="el" href="transformation_exercises.html">Transformation Exercises</a>. Here, we will you an alternative solution, we will create a rotation matrix and pass this new matrix as an <b>uniform</b> to the shader. <b>Uniforms</b> are like global variables, they hold the same value for all the vertices (or fragments if the uniform is in the fragment shader).</p>
<p>Here are the steps:</p>
<ol type="1">
<li>in the <b>render</b> method of the <b>simpleshader.hpp</b> file, create a new <em>Eigen::Affine3f</em> matrix and call it <em>rotation_matrix</em>. Set it as Identity.</li>
<li>rotate the matrix you just created by 45 degrees around the Z axis, using the <em>Eigen::AngleAxis</em></li>
<li>pass the matrix to the shader by inserting the following line below the other <em>setUniforms</em>: <div class="fragment"><div class="line">shader.setUniform(&quot;rotationMatrix&quot;, rotation_matrix);</div></div><!-- fragment --></li>
<li>in your vertex shader <b>shading.vert</b> add a line to receive the rotation matrix, look at how the other matrices are being received as uniforms. The name of our uniform in the shader should match the name in the <b>setUniform</b> method above, that is, <em>rotation_matrix</em></li>
<li>finally, multiply the <em>vert</em> vector by the rotation matrix, similar to what you did with the translation</li>
</ol>
<p>You should see your triangle like this (remember to remove the translation from the previous exercise):</p>
<blockquote class="doxtable">
<div class="image">
<img src="pipeline-exercise3.png" alt="pipeline-exercise3.png"/>
</div>
 </blockquote>
<p><br />
<br />
 </p><hr/>
<h2>Exercise 4 - passing attributes from the vertex to the fragment shader (in / out)</h2>
<blockquote class="doxtable">
<p><b>Note</b>: Remove the rotation from the previous exercise before starting. </p>
</blockquote>
<p>While <b>uniforms</b> act as global variables, <b>attributes</b> are local variables that hold specific values for each call of the shader (for each vertex or each fragment).</p>
<p>For example, every time the vertex shader is called, a different value is assigned to the <b>attribute</b> called <em>in_Position</em> (the vertex's xyzw coordinates). The word <b>in</b> precedes the <em>vec4 in_Position</em> to indicate that the variable is coming into the vertex shader.</p>
<p>When you pass an attribute per vertex to the fragment shader, the attribute will be interpolated inside the triangle (i.e. for each generated fragment).</p>
<p>When the variable in the vertex shader is preceded by the word <b>out</b> it means that it will be linearly interpolated and will be received by the fragment shader as an <b>in</b> variable.</p>
<p>In this exercise we will create a new color attribute to be interpolated, so you can better understand how this works. Follow the steps:</p>
<ol type="1">
<li>create an <b>out vec4 color</b> variable in your vertex shader. You should place it outside the main function, below the <b>in</b> variable, for example.</li>
<li>we now have to assign some value to this attribute. Just as an illustration, let's assign the value of the x, y, z coordinates of the vertex, since they are different for each vertex and you will be able to see the interpolation effect. However, since coordinates can have negative values and colors cannot, we will add a 0.5 offset to each channel, but we will keep the <b>w</b> channel as 1.0. To do so create the following lines in the main function of the vertex shader: <div class="fragment"><div class="line">color.xyz = in_Position.xyz + vec3(0.5);</div><div class="line">color.w = 1.0;</div></div><!-- fragment --></li>
</ol>
<blockquote class="doxtable">
<p><b>Note</b>: note in step <b>2</b> how in GLSL we can operate on only some elements of the vector. This is called <em>Swizzling</em> (read more about swizzling <a href="https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Swizzling">here</a>) </p>
</blockquote>
<ol type="1">
<li>the last step is to use the interpolated value in the fragment shader. In the <b>shading.frag</b> file create a new <b>in</b> variable (vec4) called <b>color</b></li>
<li>in the main function of the fragment shader, attribute the <b>color</b> value to the <b>out_Color</b> <div class="fragment"><div class="line">out_Color = color;</div></div><!-- fragment --></li>
</ol>
<p>Now, each vertex has a different color, and all the generate fragments will receive the linearly interpolated color from the three vertices depending on their coordinates inside the triangle.</p>
<p>You should see the following result:</p>
<blockquote class="doxtable">
<div class="image">
<img src="pipeline-exercise4.png" alt="pipeline-exercise4.png"/>
</div>
 </blockquote>
<p><br />
<br />
 </p><hr/>
<h2>Exercise 5 - add a new attribute to the vertices and use it in the shaders</h2>
<p>In the last exercise we create artificial colors using coordinates values just for illustration. What if you want to set specific colors to the vertices? In GLSL you could actually retrieve the vertex id inside the vertex shader, and do something like: </p><div class="fragment"><div class="line">if vertex id is 1 then color is red</div><div class="line">if vertex id is 2 then color is green</div><div class="line">if vertex id is 3 then color is blue</div></div><!-- fragment --><p>But if you have thousands of vertices and triangles you can immediately see that this becomes unfeasible. A better way is to create a new vertex attribute and set the values outside the shaders (in your C++ code).</p>
<p><a class="el" href="namespaceTucano.html">Tucano</a> allows you to add any generic attribute to the vertices. Attributes may have different values per vertex, and they are received in the vertex shader as a <b>in</b> variable. They are usually floats or 2/3/4D vectors. Your shader already has an <b>in vec4 in_Position</b>, and now we are going to add a color attribute to the vertices.</p>
<p>In the <b>createGeometry</b> method in the <b>widget.cpp</b> file, you can see that a vector of <em>Eigen::Vector4</em> called <em>vertices</em> was created, and values were assigned to the vector using <em>push_back</em>. Then the attribute was added to the mesh using the method <b>loadVertices</b>. These values are read in the vertex shader from the variable <b>in vec4 in_Position</b>. Every time the vertex shader is called for each vertex, the appropriate corresponding value will be available in this <b>in</b> attribute variable.</p>
<p>The mapping from the mesh <b>Vertices</b> attribute to the <b>in</b> variable of the shader is done by <a class="el" href="namespaceTucano.html">Tucano</a> when the method <b>setDefaultAttribLocations</b> is called. <a class="el" href="namespaceTucano.html">Tucano</a> uses the following default mapping names from mesh attributes to shader <b>in</b> variables:</p>
<ul>
<li><b>loadVertices</b> maps to <b>in_Position</b></li>
<li><b>loadNormals</b> maps to <b>in_Normal</b></li>
<li><b>loadColors</b> maps to <b>in_Color</b></li>
<li><b>loadTexCoords</b> maps to <b>in_TexCoords</b></li>
</ul>
<p>You could also create new attributes and set their own <b>in</b> names in the shader, but here we will use the default name for colors.</p>
<p>As a last remark, so far, the mesh does not know anything thing about the shader itself. The actual connection with a specific shader is done in the <b>render</b> method by calling: </p><div class="fragment"><div class="line">mesh.setAttributeLocation(shader);</div></div><!-- fragment --><p>Briefly, this methods transforms the names of the variables in locations, which are ids in GLSL. You do not really need to know about locations to complete the assignments, but if you are curious visit <a href="https://www.khronos.org/opengl/wiki/Layout_Qualifier_(GLSL)">this page</a>.</p>
<blockquote class="doxtable">
<p><b>Note</b>: Why is this necessary? Why isn't the <b>setDefaultAttribLocations</b> enough? Because one mesh could be rendered using different shaders, and the vertex attributes might have different locations (ids) in different shaders, even though the variable names are the same. This internal mapping of names and locations is done by the <b>shader</b> class in <a class="el" href="namespaceTucano.html">Tucano</a>. </p>
</blockquote>
<p>Finally, here are the steps to create the color attribute:</p>
<ol type="1">
<li>create the new attribute and assign some color values to the vertices. This is very similar to filling the vertices coordinates. Create a new vector of <em>Eigen::Vector4</em> called <b>colors</b> inside the <b>createGeometry</b> method. Now assign the following colors to the vertices (set the alpha (or w) to 1 for all colors):<ul>
<li>vertex 1: Red</li>
<li>vertex 2: Green</li>
<li>vertex 3: Blue</li>
</ul>
</li>
</ol>
<blockquote class="doxtable">
<p><b>Note</b>: do not forget to call the <b>loadColors</b> method of the mesh to load the values. </p>
</blockquote>
<ol type="1">
<li>the attribute will be automatically mapped to the shader when the method <b>setAttributeLocation</b> is called in the <b>render</b> method, so there is nothing more to be done in the C++ files.</li>
<li>in the vertex shader <b>shading.vert</b>, you need to add the following modifications:<ul>
<li>add the <b>in</b> variable called <b>in_Color</b></li>
<li>add an <b>out</b> variable called <b>color</b></li>
<li>attribute <b>in_Color</b> to <b>color</b> in the main function</li>
</ul>
</li>
<li>in the fragment shader <b>shading.frag</b>, add the following modifications:<ul>
<li>add the <b>in</b> variable called <b>color</b> (corresponding to the <b>out</b> variable in the vertex shader)</li>
<li>attribute the <b>color</b> value to the <b>out_Color</b></li>
</ul>
</li>
</ol>
<p>The result should look like this:</p>
<blockquote class="doxtable">
<div class="image">
<img src="pipeline-exercise5.png" alt="pipeline-exercise5.png"/>
</div>
 </blockquote>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Sep 26 2019 12:40:28 for Tucano by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
